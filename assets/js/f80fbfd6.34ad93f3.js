"use strict";(self.webpackChunkrimbu_docs=self.webpackChunkrimbu_docs||[]).push([[8985],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return m}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var r=i.createContext({}),c=function(e){var t=i.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},h=function(e){var t=c(e.components);return i.createElement(r.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),u=c(n),m=a,p=u["".concat(r,".").concat(m)]||u[m]||d[m]||o;return n?i.createElement(p,s(s({ref:t},h),{},{components:n})):i.createElement(p,s({ref:t},h))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=u;var l={};for(var r in t)hasOwnProperty.call(t,r)&&(l[r]=t[r]);l.originalType=e,l.mdxType="string"==typeof e?e:a,s[1]=l;for(var c=2;c<o;c++)s[c]=n[c];return i.createElement.apply(null,s)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2045:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return r},metadata:function(){return c},toc:function(){return h},default:function(){return u}});var i=n(3117),a=n(102),o=(n(7294),n(3905)),s=["components"],l={id:"advanced-list",slug:"./list",title:"List Advanced topics"},r=void 0,c={unversionedId:"advanced/advanced-list",id:"advanced/advanced-list",isDocsHomePage:!1,title:"List Advanced topics",description:"Implementation details",source:"@site/docs/advanced/list-advanced.mdx",sourceDirName:"advanced",slug:"/advanced/list",permalink:"/docs/advanced/list",editUrl:"https://github.com/rimbu-org/rimbu/edit/master/website/docs/advanced/list-advanced.mdx",tags:[],version:"current",frontMatter:{id:"advanced-list",slug:"./list",title:"List Advanced topics"},sidebar:"sidebar",previous:{title:"Collections in-depth",permalink:"/docs/advanced/in-depth"}},h=[{value:"Implementation details",id:"implementation-details",children:[],level:2},{value:"Underlying structure",id:"underlying-structure",children:[{value:"Block size",id:"block-size",children:[],level:3},{value:"Structure",id:"structure",children:[],level:3},{value:"Concatenation",id:"concatenation",children:[],level:3},{value:"Reversal",id:"reversal",children:[],level:3}],level:2},{value:"Efficiency",id:"efficiency",children:[{value:"Complexity",id:"complexity",children:[],level:3}],level:2}],d={toc:h};function u(e){var t=e.components,n=(0,a.Z)(e,s);return(0,o.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"implementation-details"},"Implementation details"),(0,o.kt)("p",null,"The Rimbu Immutable List structure is implemented in TypeScript as a block-based structure, similar to Vectors in Scala and Clojure. However the implementation differs radically in many ways from any known existing List/Vector implementation. One requirement for the Rimbu List was to allow for random insertion and deletion, which the other Vector implementations do not allow. There are other implementations (see below) that do allow insertion and deletion, however the Rimbu List uses a different approach."),(0,o.kt)("p",null,"To key to efficient insertion and deletion is to have efficient splits and concatenation. These should both be of complexity O(log(N)) for large N. When this is the case, it follows that insertion and deletion are also O(log(N)), since they can be represented as combinations of splits and concatenations. For example, imagine a List with elements (0, 1, 2, 3, 4, 5) (this is not a good example for O(log(N)) since N here is very small, but it serves as an example). We want to insert values (10, 11) at index 2. This can be done as follows:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Split the list at index 2: (0, 1), (2, 3, 4, 5)"),(0,o.kt)("li",{parentName:"ol"},"Concatenate the first part with the values to insert: (0, 1) + (10, 11) => (0, 1, 10, 11)"),(0,o.kt)("li",{parentName:"ol"},"Concatenate the result with the last part from 1: (0, 1, 10, 11) + (2, 3, 4, 5) => (0, 1, 10, 11, 2, 3, 4, 5)")),(0,o.kt)("p",null,"In total this takes 3 times O(log(N)), which is still O(log(N))."),(0,o.kt)("p",null,"Similarly, we can remove 2 values at index 2 from the same List (0, 1, 2, 3, 4, 5) as follows:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Split the list at index 2: (0, 1), (2, 3, 4, 5)"),(0,o.kt)("li",{parentName:"ol"},"Split the second list at index 2: (2, 3), (4, 5)"),(0,o.kt)("li",{parentName:"ol"},"Concatenate the first list from 1 with the second list from 2: (0, 1) + (4, 5) => (0, 1, 4, 5)")),(0,o.kt)("p",null,"Again, this takes 3 times O(log(N)), which is still O(log(N))."),(0,o.kt)("h2",{id:"underlying-structure"},"Underlying structure"),(0,o.kt)("h3",{id:"block-size"},"Block size"),(0,o.kt)("p",null,"As mentioned, a List is based on blocks of size S = 2^B where B >= 2. However, where default Scala and Clojure Vectors require all blocks to be exactly S = 2^B size, the List relaxes this requirement to be ((2^B) / 2) < S <= 2^B. Some more advanced implementations of Vectors also have such a relaxation to allow for more flexibility. Without this flexibility, it is not possible to concatenate in O(log(N)), since it may require shifting all elements in a Vector to make the blocks well aligned with another Vector."),(0,o.kt)("h3",{id:"structure"},"Structure"),(0,o.kt)("p",null,"Another difference with existing Vectors is the way blocks are connected and navigated to find elements at a certain index. A common Vector has one entry block, which contains information about its sub-blocks. Each sub-block again has information about its sub-blocks, until a leaf is reached which contains the element to be retrieved. This makes all operations relatively constant in access time: O(log(N)). Some implementations use 'caching' strategies to make successive access to values in the same block quicker."),(0,o.kt)("p",null,"The Rimbu List has a different strategy. At the entry level, is has pointers to 3 blocks: The first leaf block, the last leaf block, and a middle section. The middle section is a recursive List of Lists. More on that later. The consequence is that the first and last blocks are always immediately accessible: O(1). Often List-like structures are used mostly to append or prepend values and to look at the first and last values. The List is therefore very suitable for such cases."),(0,o.kt)("p",null,"Then about the middle section. As mentioned, this is a List of Lists. Meaning, that again, it has references to three parts: the first block of sub-lists, the last block of sub-lists, and a middle section again containing a List of sub-lists (and so forth). Because the first and last blocks now contain blocks instead of elements, finding a specific element requires finding the corresponding sub-list in the first or last block, and then retrieving the element in that sub-list. The consequence is that, while elements at the start or end of the list are accessed very quickly, elements at the middle of the collection take longer to retrieve (for a large collection or small block size), but still O(log(N))."),(0,o.kt)("h3",{id:"concatenation"},"Concatenation"),(0,o.kt)("p",null,"The nice thing about this structure is that splitting and concatenation become nice recursive features. In the case of a split, this involves finding the leaf block containing the split, splitting that leaf block, and setting the remainder of the block as the new top-level end block. The sub-block that used to point to the leaf block is split to no longer include the elements from the selected leaf block. The remained is concatenated with the middle section. This happens recursively. Since the amount of nesting levels of the tree is O(log(N)), it follows that the process of splitting is O(log(N))."),(0,o.kt)("p",null,"A similar process happens for concatenation. For List A and B to be concatenated, the last block of A and first block of B are concatenated. The resulting block is then appended to the middle section of List A, and the middle section of B is then concatenated. Again, this happens recursively for each level, resulting in O(log(N)) for concatenation."),(0,o.kt)("h3",{id:"reversal"},"Reversal"),(0,o.kt)("p",null,"Each block in a List can be reversed without copying the underlying data. Basically, each block has a boolean indicating whether the block elements should be read from left to right, or right to left. To reverse a block, the pointer to the elements remains the same, but the new block has an inverted boolean. Therefore, to reverse an entire List, each block needs to flip its switch. There are approx. log(N) blocks in a List, therefore reversing a List has complexity O(log(N))."),(0,o.kt)("p",null,"A List can have mixed reversed and non-reversed blocks, which is necessary to keep the same performance when concatenating a non-reversed and a reversed List. In such a case, at most some elements will need to be copied since within a block all elements need to have the same direction. But other blocks can be kept as is."),(0,o.kt)("h2",{id:"efficiency"},"Efficiency"),(0,o.kt)("h3",{id:"complexity"},"Complexity"),(0,o.kt)("p",null,"The nature of the List data structure is such that retrieving random elements has complexity O(logB(N)), where N is the length of the collection, and B is the block size. While not bad, this is still slow compared to an Array, which has constant access time (O(1))."),(0,o.kt)("p",null,"However, knowing the characteristics of the List implementation can help circumventing this drawback."),(0,o.kt)("p",null,"Firstly, retrieval time in a List depends on the index within the List. At both the start and the end of the List, the complexity is O(1). The complexity increases to a maximum of O(logB(N)) towards the middle of the List. The consequence is that, for large Lists, it takes more time to retrieve an element towards the middle of a list than at the start or end."),(0,o.kt)("p",null,"Secondly, the List makes it easy to retrieve subparts using ",(0,o.kt)("inlineCode",{parentName:"p"},".slice")," or ",(0,o.kt)("inlineCode",{parentName:"p"},".streamRange"),". Imagine we have a List of 10,000 elements. We have some algorithm that averages 10 consecutive values of the list at some index. The worst thing we can do is write a for-loop that performs ",(0,o.kt)("inlineCode",{parentName:"p"},"List.get(i)")," 10 times, because it will take 10 times O(logB(10000))."),(0,o.kt)("p",null,"A better idea would be to use the ",(0,o.kt)("inlineCode",{parentName:"p"},".slice")," or ",(0,o.kt)("inlineCode",{parentName:"p"},".streamRange")," methods. Both only take one time the O(logB(10000)) and then allow nearly constant time access to the subsequent values."),(0,o.kt)("p",null,"The same holds for many other methods, like ",(0,o.kt)("inlineCode",{parentName:"p"},".forEach")))}u.isMDXComponent=!0}}]);