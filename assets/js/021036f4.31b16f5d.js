"use strict";(self.webpackChunkrimbu_docs=self.webpackChunkrimbu_docs||[]).push([[25003],{15680:(e,t,n)=>{n.d(t,{xA:()=>m,yg:()=>y});var o=n(96540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),c=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=c(e.components);return o.createElement(s.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=c(n),d=a,y=u["".concat(s,".").concat(d)]||u[d]||p[d]||i;return n?o.createElement(y,r(r({ref:t},m),{},{components:n})):o.createElement(y,r({ref:t},m))}));function y(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,r[1]=l;for(var c=2;c<i;c++)r[c]=n[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},57977:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>b,contentTitle:()=>g,default:()=>N,frontMatter:()=>y,metadata:()=>h,toc:()=>f});var o=n(15680),a=Object.defineProperty,i=Object.defineProperties,r=Object.getOwnPropertyDescriptors,l=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,m=(e,t,n)=>t in e?a(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,u=(e,t)=>{for(var n in t||(t={}))s.call(t,n)&&m(e,n,t[n]);if(l)for(var n of l(t))c.call(t,n)&&m(e,n,t[n]);return e},p=(e,t)=>i(e,r(t)),d=(e,t)=>{var n={};for(var o in e)s.call(e,o)&&t.indexOf(o)<0&&(n[o]=e[o]);if(null!=e&&l)for(var o of l(e))t.indexOf(o)<0&&c.call(e,o)&&(n[o]=e[o]);return n};const y={slug:"introducing-rimbu",title:"Introducing Rimbu",author:"Arvid Nicolaas",author_title:"Rimbu Author",author_url:"https://github.com/vitoke",author_image_url:"https://github.com/vitoke.png",tags:["rimbu","immmutable","collections","typescript"]},g=void 0,h={permalink:"/blog/introducing-rimbu",editUrl:"https://github.com/rimbu-org/rimbu/edit/master/website/blog/blog/2021-09-03-introducing-rimbu.md",source:"@site/blog/2021-09-03-introducing-rimbu.md",title:"Introducing Rimbu",description:"Immutable collections and tools for TypeScript",date:"2021-09-03T00:00:00.000Z",formattedDate:"September 3, 2021",tags:[{label:"rimbu",permalink:"/blog/tags/rimbu"},{label:"immmutable",permalink:"/blog/tags/immmutable"},{label:"collections",permalink:"/blog/tags/collections"},{label:"typescript",permalink:"/blog/tags/typescript"}],readingTime:5.68,hasTruncateMarker:!1,authors:[{name:"Arvid Nicolaas",title:"Rimbu Author",url:"https://github.com/vitoke",imageURL:"https://github.com/vitoke.png"}],frontMatter:{slug:"introducing-rimbu",title:"Introducing Rimbu",author:"Arvid Nicolaas",author_title:"Rimbu Author",author_url:"https://github.com/vitoke",author_image_url:"https://github.com/vitoke.png",tags:["rimbu","immmutable","collections","typescript"]},nextItem:{title:"How it all got started",permalink:"/blog/how-it-got-started"}},b={authorsImageUrls:[void 0]},f=[{value:"Immutable collections and tools for TypeScript",id:"immutable-collections-and-tools-for-typescript",level:2},{value:"Immutability: Create safer code",id:"immutability-create-safer-code",level:3},{value:"Smart and strong type safety",id:"smart-and-strong-type-safety",level:3},{value:"Performance: Rimbu collections designed for performance",id:"performance-rimbu-collections-designed-for-performance",level:3},{value:"Simplicity",id:"simplicity",level:3},{value:"But still, what about <code>immmutable.js</code>?",id:"but-still-what-about-immmutablejs",level:3},{value:"What&#39;s to come?",id:"whats-to-come",level:3}],v={toc:f},w="wrapper";function N(e){var t=e,{components:n}=t,a=d(t,["components"]);return(0,o.yg)(w,p(u(u({},v),a),{components:n,mdxType:"MDXLayout"}),(0,o.yg)("h2",u({},{id:"immutable-collections-and-tools-for-typescript"}),"Immutable collections and tools for TypeScript"),(0,o.yg)("p",null,"A new collection library for TypeScript? Aren't ",(0,o.yg)("inlineCode",{parentName:"p"},"Array"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"Set"),", and ",(0,o.yg)("inlineCode",{parentName:"p"},"Map")," good enough? What about ",(0,o.yg)("inlineCode",{parentName:"p"},"immutable.js"),"? Well, I understand you have a lot of questions\nmy friend. Let me start by describing what Rimbu is all about."),(0,o.yg)("h3",u({},{id:"immutability-create-safer-code"}),"Immutability: Create safer code"),(0,o.yg)("p",null,"When you start using TypeScript, you are taught it is better to use ",(0,o.yg)("inlineCode",{parentName:"p"},"const")," where possible instead of ",(0,o.yg)("inlineCode",{parentName:"p"},"let")," or ",(0,o.yg)("inlineCode",{parentName:"p"},"var"),". Why is that? Well, mainly because, once you\nassign a value with ",(0,o.yg)("inlineCode",{parentName:"p"},"const"),", you cannot change its value. If you want a new value from that value, you will need to write a new ",(0,o.yg)("inlineCode",{parentName:"p"},"const")," and give it a new name:"),(0,o.yg)("pre",null,(0,o.yg)("code",u({parentName:"pre"},{className:"language-ts"}),"const a = 5;\na += 1; // Compiler error!\nconst b = a + 1; // OK\n")),(0,o.yg)("p",null,"However, this principle breaks down when we use referenced values like ",(0,o.yg)("inlineCode",{parentName:"p"},"object")," or ",(0,o.yg)("inlineCode",{parentName:"p"},"Array"),". When we assign such a value to a ",(0,o.yg)("inlineCode",{parentName:"p"},"const"),", we cannot make it ",(0,o.yg)("inlineCode",{parentName:"p"},"null"),". But we\ncan change its contents:"),(0,o.yg)("pre",null,(0,o.yg)("code",u({parentName:"pre"},{className:"language-ts"}),"const arr = [1, 2, 3];\narr.length = 0; // this is fine\nconsole.log(arr);\n// => []\n")),(0,o.yg)("p",null,"You see that we can certainly change the value even though we use ",(0,o.yg)("inlineCode",{parentName:"p"},"const"),". This breaks the whole story about not being able to change ",(0,o.yg)("inlineCode",{parentName:"p"},"const")," values!"),(0,o.yg)("p",null,"This is where immutable collections and objects come in to save the day. An immutable object, by definition, cannot be changed. Once it's created, its values\nwill always be the same, no matter what you do to it. Combined with ",(0,o.yg)("inlineCode",{parentName:"p"},"const"),", we have back our sacred principle of not being able to change assigned values."),(0,o.yg)("p",null,"But, I hear you say, what's the use? How can we add values to immutable collections? Well, it simply the same as the story of adding 1 to a ",(0,o.yg)("inlineCode",{parentName:"p"},"const")," number:"),(0,o.yg)("pre",null,(0,o.yg)("code",u({parentName:"pre"},{className:"language-ts"}),"import { List } from '@rimbu/collections';\n\nconst list1 = List.of(1, 2, 3);\nconst list2 = list1.append(4);\n\nconsole.log(list2.toString());\n// => List(1, 2, 3, 4);\nconsole.log(list1.toString());\n// => List(1, 2, 3);\n")),(0,o.yg)("p",null,"In this example you can clearly see that ",(0,o.yg)("inlineCode",{parentName:"p"},"list2")," is a new list with other values than ",(0,o.yg)("inlineCode",{parentName:"p"},"list1"),". Even though we added a value to ",(0,o.yg)("inlineCode",{parentName:"p"},"list1"),", its contents did\nnot change. This is exactly the benefit of immutability, you never have to worry about values having changed while you were not looking."),(0,o.yg)("h3",u({},{id:"smart-and-strong-type-safety"}),"Smart and strong type safety"),(0,o.yg)("p",null,"Rimbu goes to great lenghts to ensure that the compiler will 'understand' what you are trying to do, but still prevent you from making obvious mistakes.\nFor example, imagine the following:"),(0,o.yg)("pre",null,(0,o.yg)("code",u({parentName:"pre"},{className:"language-ts"}),"import { List } from '@rimbu/collection';\nconst list1 = List.of(1, 2, 3);\n// type of list1: List.NonEmpty<number>\nconst list2 = list1.append('a'); // error: string is not assignable to number\nconst list3 = list1.extendType<number | string>().append('a');\n// type of list3: List.NonEmpty<number | string>\n")),(0,o.yg)("p",null,"The compiler will rightly prevent you from appending a string to a list of numbers. However, you can still do that without needing to cast using the ",(0,o.yg)("inlineCode",{parentName:"p"},"extendType")," method.\nFurthermore, you see that the lists get type ",(0,o.yg)("inlineCode",{parentName:"p"},"List.NonEmpty")," instead of ",(0,o.yg)("inlineCode",{parentName:"p"},"List"),". All Rimbu collections have this type information to indicate whether the compiler can know at\ncompile time that the collection has at least one value. This allows us to write code that by definition rejects empty collections, and saves us from having to write\nchecks for empty collections and thinking about how to handle such situations. In particular, it saves us from writing boring tests."),(0,o.yg)("p",null,"These are just small examples from a plethora of built-in smartness that the Rimbu collections possess."),(0,o.yg)("h3",u({},{id:"performance-rimbu-collections-designed-for-performance"}),"Performance: Rimbu collections designed for performance"),(0,o.yg)("p",null,"Because immutable collections are often described as 'copying' data, they are often assumed to be slow. However, there is a principle called 'persistence', which\nallows them to actually be really fast. Persistance actually means memory sharing. Rimbu immutable collections will share memory as much as possible as long as no\nchanges need to be made. The collections only duplicates parts of shared data that are modified. The rest of the data remains shared. This is because the collections\nkeep their data in block-like structures, comparable to blocks on hard-drives. If some collection uses 50 blocks of data, and one value is changed, chances are that only 2 or 3 blocks need to be copied and changed, while the rest stays the same and shared. In some cases, persistent collections can be faster than mutable collections. For example, reversing a ",(0,o.yg)("inlineCode",{parentName:"p"},"List")," of N elements in Rimbu has complexity O(logM(N)) where M is usually 32, so it is really fast for large collections as well. For a mutable array, the complexity is O(N), and therefore much slower. A similar story goes for memory complexity, however I will probably cover this topic some other time."),(0,o.yg)("h3",u({},{id:"simplicity"}),"Simplicity"),(0,o.yg)("p",null,"Rimbu is mostly about giving the programmer new powerful tools to write safe and effective programs that are simple. For example, it avoids using advanced functional\nprogramming concepts like Monads, because they make code harder to understand and read."),(0,o.yg)("p",null,"This is why you will not find an ",(0,o.yg)("inlineCode",{parentName:"p"},"Option")," or ",(0,o.yg)("inlineCode",{parentName:"p"},"Maybe")," type (which are monads). Still, Rimbu provides nearly the same power in all methods that can fail:"),(0,o.yg)("pre",null,(0,o.yg)("code",u({parentName:"pre"},{className:"language-ts"}),"import { List, err } from '@rimbu/core';\n\nconst list = List.of(1, 2, 3);\n\nconst v1 = list.getAtIndex(1);\n// type of v1: number | undefined\n\nconst v2 = list.getAtIndex(1, 'not found');\n// type of v2: number | 'not found'\n\nconst v3 = list.getAtIndex(1, -1); // return -1 if not found\n// type of v3: number\n\nconst v4 = list.getAtIndex(1, () => 'lazy failure');\n// type of v4: number | 'lazy failure'\n\n// err is a function that throws an error when invoked\nconst v5 = list.getAtIndex(1, err);\n// type of v5: number\n")),(0,o.yg)("p",null,"In this way it is not needed to write things like ",(0,o.yg)("inlineCode",{parentName:"p"},"list.getOption(..).map(..).getOrElse(..)")," or ",(0,o.yg)("inlineCode",{parentName:"p"},"if (list.get(1) === undefined) throw Error()")),(0,o.yg)("h3",u({},{id:"but-still-what-about-immmutablejs"}),"But still, what about ",(0,o.yg)("inlineCode",{parentName:"h3"},"immmutable.js"),"?"),(0,o.yg)("p",null,"Of course we already have a very nice JavaScript immutable collection library for years, called ",(0,o.yg)("inlineCode",{parentName:"p"},"immutable.js"),". To be honost, I've never used it myself in projects,\nbut I have read their documentation. The first thing that strikes me, in comparison to Rimbu, is that ",(0,o.yg)("inlineCode",{parentName:"p"},"immutable.js")," is focused firstly on JavaScript and\nadded types later on. Secondly, it has a few basic collections, like Maps and Sets, but Rimbu has many more (up to ",(0,o.yg)("inlineCode",{parentName:"p"},"Graphs"),"). Finally, it has ",(0,o.yg)("inlineCode",{parentName:"p"},"Records")," to\ndefine immutable objects. However, with TypeScript, we can use the compiler to supply deep readonly types that prevent modification of plain objects. In this way\nthis is a very lightweight and easier to use approach."),(0,o.yg)("h3",u({},{id:"whats-to-come"}),"What's to come?"),(0,o.yg)("p",null,"In the coming time, I want to write much more documentation, and I hope to receive feedback on the current state of the library from other users. If there\nare requests for other types of collections, I would be willing to implement them and add them to the library."))}N.isMDXComponent=!0}}]);